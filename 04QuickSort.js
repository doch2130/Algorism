// 퀵 정렬

// 데이터가 10만 개만 넘어가도 선택, 버블, 삽입은 사용하기가 어렵다.
// 분할 정복 알고리즘으로 평균 속도가 O(N* logN)이다.

// 특정한 값을 기준으로 큰 숫자와 작은 숫자를 나누면 어떨까?
// 값을 /2를 하는게 아니라 배열을 반으로 쪼갠다고 보면 된다고 한다.

// 문제
// 오름차순 정렬하는 프로그램
// 3, 7, 8, 1, 5, 9, 6, 10, 2, 4

// 내림차순으로 변경하고 싶은 경우 조건문의 부등호만 변경해주면 된다.

const array = [3, 7, 8, 1, 5, 9, 6, 10, 2, 4];
// const array = [10, 1, 2, 3, 4, 5];

console.log('start array ', array);
// 코드 시작
function quickSort(data, start, end) {
  if (start >= end) {
    // 원소가 1개인 경우
    return;
  }
  // 키는 첫번째 원소
  let key = start;
  let i = start + 1;
  let j = end;
  let temp = 0;

  while (i <= j) {
    // 엇갈릴 때까지 반복
    while (data[key] >= data[i] && i <= end) {
      // 키 값보다 큰 값을 만날 때까지 반복
      // 키 값이 제일 큰 값인 경우 범위를 넘어가는 현상을 방지하기 위해 i <= end 설정
      i++;
      if (i > data.length) {
        i = 0;
        break;
      }
    }
    while (data[key] <= data[j] && j > start) {
      // 키 값보다 작은 값을 만날 때까지 반복
      // 키 값보다 작은 값을 못찾아서 범위를 넘어가는 경우를 방지하기 위해 j > start를 설정
      j--;
    }
    if (i >= j) {
      // 엇갈린 상태면 키 값과 교체
      // temp = data[j];
      // data[j] = data[key];
      // data[key] = temp;
      // 사실 똑같은 코드임
      temp = data[key];
      data[key] = data[j];
      data[j] = temp;
    } else {
      temp = data[j];
      data[j] = data[i];
      data[i] = temp;
    }
  }

  quickSort(data, start, j - 1);
  quickSort(data, j + 1, end);
}

quickSort(array, 0, array.length - 1);
// 코드 끝
console.log('finaly array ', array);

// 주로 가장 앞의 값을 피벗 값으로 설정한다고 함

// 3, 7, 8, 1, 5, 9, 6, 10, 2, 4
// 3을 기준으로 앞에서 큰 값을 뒤에서 작은 값을 찾는다.

// 3, 7, 8, 1, 5, 9, 6, 10, 2, 4
// 3, 2, 8, 1, 5, 9, 6, 10, 7, 4
// 3, 2, 1, 8, 5, 9, 6, 10, 7, 4

// 큰 값 8, 작은값 1 => 서로 엇갈린 경우
// 작은 값과 피벗 값을 바꿔준다.
// 3을 기준으로 왼쪽 집합은 정렬이 되었다고 볼 수 있게 된다.
// 1, 2, 3, 8, 5, 9, 6, 10, 7, 4

// 왼쪽 집합 피벗 1
// 오른쪽 집합 피벗 8
// 왼쪽에서 정렬을 진행
// 1, 2
// 바뀔 값이 없으므로
// 1, 2, 3, ...
// 1, 3은 고정되고 2는 1개뿐이므로 그대로 종료
// 1, 2, 3, 8, 5, 9, 6, 10, 7, 4
// 오른쪽 정렬 진행
// 1, 2, 3, 8, 5, 4, 6, 10, 7, 9
// 1, 2, 3, 8, 5, 4, 6, 7, 10, 9
// 엇갈림
// 1, 2, 3, 7, 5, 4, 6, 8, 10, 9
// 한번더 피벗 값 선택
// 왼쪽 7, 오른쪽 10
// 1, 2, 3, 7, 5, 4, 6, 8, 10, 9
// 엇갈림 7보다 큰값이 없음
// 1, 2, 3, 6, 5, 4, 7, 8, 10, 9
// 6이 피벗으로 설정
// 엇갈림 6보다 큰값이 없음
// 1, 2, 3, 4, 5, 6, 7, 8, 10, 9
// 1, 2, 3, 4, 5, 6, 7, 8, 9, 10

// 선택, 버블, 삽입
// 1 2 3 4 5 6 7 8 9 10
// 10 * 10 = 100

// 퀵
// 1 2 3 4 5  // 6 7 8 9 10
// 5 * 5 = 25 // 5 * 5 = 25
// 50

// 퀵 정렬의 평균 시간 복잡도는 O(N * logN)입니다.
// 하지만 최악 시간 복잡도는 O(N^2)이다.

// 최악의 경우
// 1 2 3 4 5 6 7 8 9 10
// 이미 정렬이 된 경우
// 큰 값을 찾아도, 작은 값이 곧 key 값이라서
// 정렬을 해도 분할 방법을 사용할 수 가 없게 된다.
// 퀵 정렬이라도 모든 상황에서 빠르지는 않다.
